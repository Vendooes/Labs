import numpy as np
import matplotlib.pyplot as plt
from scipy.optimize import curve_fit

# Данные из таблицы
data = {
    'v, МГц': [3.890, 7.810, 11.710, 15.710, 19.610, 23.510, 27.510, 31.510, 35.410, 39.410],
    'U0, МГц': [54.0, 54.0, 53.9, 54.1, 54.0, 53.9, 54.0, 54.0, 53.9, 54.0],
    'UH, МГц': [48.4, 46.0, 43.6, 41.2, 40.8, 39.6, 38.8, 36.0, 34.2, 33.2],
    'Δφ, рад': [5.19984, 10.06684, 15.61459, 19.70162, 24.7947, 29.87082, 34.94192, 39.61738, 46.36901, 51.42064],
    'k, 10^-3 см^-1': [1.03377, 2.00136, 3.10429, 3.91682, 4.92936, 5.93853, 6.9467, 7.87622, 9.21849, 10.22279],
    'α, 10^-2 см^-1': [0.02177, 0.03188, 0.04253, 0.05379, 0.05579, 0.06166, 0.06572, 0.08061, 0.09081, 0.09671]
}

# Преобразуем в numpy массивы
v = np.array(data['v, МГц']) * 1e6  # переводим в Гц
alpha = np.array(data['α, 10^-2 см^-1']) * 1e-2  # переводим в см^-1
k = np.array(data['k, 10^-3 см^-1']) * 1e-3  # переводим в см^-1

# Вычисляем x_3 = v^(3/2) и y_3 = α(ω) * k(ω)
x_3 = v ** (3/2)
y_3 = alpha * k

# Условная погрешность: 5% от y_3 (можно заменить на реальные значения!)
y_err = 0.05 * y_3  # 5% от значения

# Функция для аппроксимации (линейная)
def linear_func(x, a, b):
    return a * x + b

# Аппроксимация
popt, pcov = curve_fit(linear_func, x_3, y_3)

# Построение графика
plt.figure(figsize=(10, 6))
plt.errorbar(x_3, y_3, yerr=y_err, fmt='o', color='blue', ecolor='gray', 
             elinewidth=2, capsize=4, label='Экспериментальные данные с погрешностями')
plt.plot(x_3, linear_func(x_3, *popt), 'r-', linewidth=2, label=f'Аппроксимация: y = {popt[0]:.2e}·x + {popt[1]:.2e}')

plt.xlabel('v^(3/2) [Гц^(3/2)]')
plt.ylabel('α(ω) · k(ω) [см⁻²]')
plt.title('Зависимость α(ω) · k(ω) от v^(3/2) с погрешностями')
plt.legend()
plt.grid(True, alpha=0.3)
plt.tight_layout()
plt.show()

# Вывод параметров аппроксимации
print(f"Параметры линейной аппроксимации:")
print(f"a = {popt[0]:.6e}")
print(f"b = {popt[1]:.6e}")